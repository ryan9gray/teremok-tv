//
//  SerialInteractor.swift
//  Teremok-TV
//
//  Created by R9G on 06/09/2018.
//  Copyright (c) 2018 xmedia. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SerialBusinessLogic {
    func fetchVideos()
    func addToFav(idx: Int)

    func downloadVideo(idx: Int, completion : @escaping (_ like : Bool) -> ())

    var hasMore : Bool { get }
}

protocol SerialDataStore {
    var razdelId: Int? { get set }
    var videoItems: [VideoModel] { get set }
    var screen: Serial.Screen { get set }

}

class SerialInteractor: SerialBusinessLogic, SerialDataStore {

    var videoItems: [VideoModel] = []
    var razdelId: Int?
    var screen: Serial.Screen = .catalog

    var presenter: SerialPresentationLogic?
    
    var nextShift: Int?
    let countSerials = 10
    var hasMore : Bool = true
    
    let service: SerialsProtocol = SerialsService()
    var searchService: SearchProtocol = SearchService()

    var videoService: VideoServiceProtocol = VideoService()


    func fetchVideos(){
        switch screen {
            case .catalog:
                break
            case .razdel(let id):
                fetchVideo(id: id)
                razdelId = id
            case .search(let text):
                search(text: text)
        }
    }

    func fetchVideo(id: Int) {
        guard hasMore   else { return }

        service.getVideos(itemsOnPage: countSerials, shiftItem: nextShift ?? 0, seriesId: id) { [weak self] (result) in
            switch result {
            case .success(let videos):
                self?.response(videos: videos)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
            }
        }
    }
    
    func search(text: String) {
        guard hasMore else { return }

        searchService.getSearch(text: text, itemsOnPage: countSerials, shiftItem: nextShift ?? 0) { [weak self] (result) in
            switch result {
            case .success(let response):
                self?.response(videos: response)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
                //self?.presenter?.backToSearch()
            }
        }
    }

    func downloadVideo(idx: Int, completion : @escaping (_ like : Bool) -> ()){
        guard let item = videoItems[safe: idx] else {
            self.presenter?.present(errorString: "Не получилось добавить в скачанное", completion: nil)
            return
        }
        videoService.downloadVideo(item: item)
    }

    func addToFav(idx: Int){
        guard let id = videoItems[safe:idx]?.id else { return }
        presenter?.present(items: videoItems)

        videoService.addToFav(id: id) { _ in

        }
    }
    
    func response(videos: VideoResponse){
        guard let items = videos.items else { return }

        self.nextShift = videos.startItemIdInNextPage
        self.hasMore = items.count > 0
        self.videoItems.append(contentsOf: items)
        
        self.presenter?.present(items: items)
    }

}
