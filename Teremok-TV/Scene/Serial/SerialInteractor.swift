//
//  SerialInteractor.swift
//  Teremok-TV
//
//  Created by R9G on 06/09/2018.
//  Copyright (c) 2018 xmedia. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SerialBusinessLogic {
    func fetchVideos()
    func addToFav(idx: Int)

    func downloadVideo(idx: Int, completion : @escaping (_ like : Bool) -> ())

    var hasMore : Bool { get }
}

protocol SerialDataStore {
    var razdelId: Int? { get set }
    var videoItems: [VideoModel] { get set }
    var screen: Serial.Screen { get set }

}

class SerialInteractor: SerialBusinessLogic, SerialDataStore {
    var presenter: SerialPresentationLogic?

    var imageLoader = ImageLoader()
    let service: SerialsProtocol = SerialsService()
    var searchService: SearchProtocol = SearchService()
    var videoService: VideoServiceProtocol = VideoService()

    var videoItems: [VideoModel] = []
    var razdelId: Int?
    var screen: Serial.Screen = .catalog
    var nextShift: Int?
    let countSerials = 10
    var hasMore : Bool = true


    init() {
         videoService.imageLoader = imageLoader
     }

    func fetchVideos(){
        switch screen {
            case .catalog:
                break
            case .razdel(let id):
                fetchVideo(id: id)
                razdelId = id
            case .search(let text):
                search(text: text)
        }
    }

    func fetchVideo(id: Int) {
        guard hasMore   else { return }

        service.getVideos(itemsOnPage: countSerials, shiftItem: nextShift ?? 0, seriesId: id) { [weak self] (result) in
            switch result {
            case .success(let videos):
                self?.response(videos: videos)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
            }
        }
    }
    
    func search(text: String) {
        guard hasMore else { return }

        searchService.getSearch(text: text, itemsOnPage: countSerials, shiftItem: nextShift ?? 0) { [weak self] result in
            switch result {
            case .success(let response):
                self?.response(videos: response)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
                //self?.presenter?.backToSearch()
            }
        }
    }

    func downloadVideo(idx: Int, completion : @escaping (_ like : Bool) -> ()){
        guard let item = videoItems[safe: idx] else {
            presenter?.present(errorString: "Не получилось добавить в скачанное", completion: nil)
            return
        }
        guard
            let urlString = item.downloadLink,
            let id = item.id,
            let link =  URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!),
            let imageLinkString = item.picture,
            let pictureURL = URL(string: imageLinkString),
            let name = item.name
        else { return }

        imageLoader.dataFrom(url: pictureURL) { [unowned self] art in
            self.videoService.hlsDownload(url: link, name: name, art: art, id: id)
        }
    }

    func addToFav(idx: Int){
        guard let id = videoItems[safe:idx]?.id else { return }
         
        presenter?.present(items: videoItems)
        videoService.addToFav(id: id) { _ in }
    }
    
    func response(videos: VideoResponse){
        guard let items = videos.items else { return }

        nextShift = videos.startItemIdInNextPage
        hasMore = items.count > 0
        videoItems.append(contentsOf: items)
        presenter?.present(items: items)
    }

}
