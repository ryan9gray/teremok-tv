//
//  PreviewInteractor.swift
//  Teremok-TV
//
//  Created by R9G on 05/09/2018.
//  Copyright (c) 2018 xmedia. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol PreviewBusinessLogic {
    func fetchData()
    func fetchRecomandation(idx: Int)
    func addToFav()
    func dowload()
}

protocol PreviewDataStore {
    var videoModel: VideoModel? {get set}
    var videoItem: VideoItemModel? {get set}
    var razdId: Int? { get set }
    var model: Preview.ItemType!  { get set }
}

class PreviewInteractor: PreviewBusinessLogic, PreviewDataStore {
    var model: Preview.ItemType!
    var videoItem: VideoItemModel?
    var videoModel: VideoModel?
    var imageLoader = ImageLoader()
    var razdId: Int?

    var presenter: PreviewPresentationLogic?
    let service: PreviewProtocol = PreviewService()
    var videoService: VideoServiceProtocol = VideoService()
    var oflineIdx: Int = 0

    init() {
        NotificationCenter.default.addObserver(self, selector: #selector(self.playerEnd), name: .AVPlayerItemDidPlayToEndTime, object: nil)
        videoService.imageLoader = imageLoader
    }

    @objc func playerEnd(){
        nextItem()
    }
    
    func fetchData() {
        guard let model = model else { return }
        switch model {
        case .online(let id):
            fetchVideo(id: id)
        case .offline(let idx, let offlineVideos):
            oflineIdx = idx
            presenter?.presentVideo(link: offlineVideos[idx].videoUrl)
            presenter?.presentRecomendet(offlineVideos)
        }
    }
    
    func fetchRecomandation(idx: Int) {
        guard let model = model else { return }
        switch model {
        case .online:
            guard let id = self.videoItem?.recommendations?[safe: idx]?.id else { return }
            fetchVideo(id: id)
        case .offline( _, let offlineVideos):
            oflineIdx = idx
            presenter?.presentVideo(link: offlineVideos[idx].videoUrl)
            presenter?.presentRecomendet(offlineVideos)
            
        }
    }
    
    func nextItem() {
        guard let model = model else { return }
        switch model {
        case .online:
            guard let nextId = videoItem?.nextItem else { return }
            fetchVideo(id: nextId)
        case .offline( _, let offlineVideos):
            oflineIdx += 1
            guard let url = offlineVideos[safe: oflineIdx]?.videoUrl else { return }
            presenter?.presentVideo(link: url)
        }
    }
    
    func fetchVideo(id: Int){
        service.getVideo(id: id, razdId: self.razdId) { [weak self] (result) in
            switch result {
            case .success(let video):
                self?.showVideo(response: video)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
            }
        }
    }
    
    func addToFav(){
        guard let id = videoModel?.id else {
            return
        }
        videoService.addToFav(id: id) { _ in }
    }

    func showVideo(response: VideoItemModel){
        videoItem = response
        videoModel = response.videoItem
        presenter?.presentVideo(response)
    }
    

    func dowload(){
        downloadHLS()
    }

    func downloadHLS() {
        guard
            let urlString = videoItem?.stream,
            let id = videoModel?.id,
            let link =  URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!),
            let imageLinkString = videoModel?.picture,
            let pictureURL = URL(string: imageLinkString),
            let name = videoModel?.name
        else { return }

        imageLoader.dataFrom(url: pictureURL) { [unowned self] art in
            self.videoService.hlsDownload(url: link, name: name, art: art, id: id)
        }
    }
    
    deinit {
		NotificationCenter.default.post(name: NSNotification.Name.ProfileNeedReload, object: nil)
        NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil)
    }
}
