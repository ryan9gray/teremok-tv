//
//  SearchMusicViewController.swift
//  Teremok-TV
//
//  Created by Evgeny Ivanov on 14/04/2019.
//  Copyright (c) 2019 xmedia. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SearchMusicDisplayLogic: CommonDisplayLogic, UITextFieldDelegate {
    func displayPlaylist(_ playlist: [SearchMusic.Track])
}

class SearchMusicViewController: MusicViewController, SearchMusicDisplayLogic {
    var interactor: SearchMusicBusinessLogic?
    var router: (NSObjectProtocol & SearchMusicRoutingLogic & SearchMusicDataPassing & CommonRoutingLogic)?
    var modallyControllerRoutingLogic: CommonRoutingLogic? {
        get { return router }
    }
    var activityView: LottieHUD?
    // MARK: Object lifecycle

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    // MARK: Setup

    private func setup() {
        let viewController = self
        let interactor = SearchMusicInteractor()
        let presenter = SearchMusicPresenter()
        let router = SearchMusicRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    // MARK: View lifecycle

    @IBOutlet private var searchFld: UITextField!
    @IBOutlet private var collectionView: UICollectionView!

    var items: [SearchMusic.Track] = [] {
        didSet {
            collectionView.reloadData()
        }
    }

    @IBAction func searchClick(_ sender: Any) {
        toSearchText()
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        prepareUI()
    }

    func prepareUI(){
        activityView = LottieHUD()
        collectionView.delegate = self
        let cells = [SearchMusicCollectionViewCell.self, LoadingCollectionViewCell.self]
        collectionView.register(cells: cells)
    }

    func displayPlaylist(_ playlist: [SearchMusic.Track]) {
        items = playlist
    }

    @objc func search(term: String){
        let searchText = searchFld.text ?? ""
        print("searching of \(searchText)")
    }
    func toSearchText(){
        guard let txt = searchFld.text, !txt.isEmpty else {
            return
        }
        view.endEditing(true)
        interactor?.search(phrase: txt)
        resetValues()
    }


    func textFieldDidBeginEditing(_ textField: UITextField) {
    }

    func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
        return true
    }

    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        toSearchText()
        return true
    }

    var autoCompleteCharacterCount = 0
    var timer = Timer()

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { //1
        var subString = (textField.text!.capitalized as NSString).replacingCharacters(in: range, with: string) // 2
        subString = formatSubstring(subString: subString)

        if subString.count == 0 { // 3 when a user clears the textField
            resetValues()
        } else {
            searchAutocompleteEntriesWIthSubstring(substring: subString) //4
        }
        return true
    }
    func formatSubstring(subString: String) -> String {
        let formatted = String(subString.dropLast(autoCompleteCharacterCount)).lowercased().capitalized //5
        return formatted
    }

    func resetValues() {
        autoCompleteCharacterCount = 0
        searchFld.text = ""
    }

    func searchAutocompleteEntriesWIthSubstring(substring: String) {
        let userQuery = substring
        print("substring " + substring)
        getAutocompleteSuggestions(userText: substring) { [weak self] suggestions in
            guard let self = self else { return }

            if suggestions.count > 0 {
                self.timer = .scheduledTimer(withTimeInterval: 0.01, repeats: false, block: { (timer) in //2
                    let autocompleteResult = self.formatAutocompleteResult(substring: substring, possibleMatches: suggestions) // 3
                    self.putColourFormattedTextInTextField(autocompleteResult: autocompleteResult, userQuery : userQuery) //4
                    self.moveCaretToEndOfUserQueryPosition(userQuery: userQuery) //5
                })
            } else {
                self.timer = .scheduledTimer(withTimeInterval: 0.01, repeats: false, block: { (timer) in //7
                    self.searchFld.text = substring
                })
                self.autoCompleteCharacterCount = 0
            }
        }
    }

    func getAutocompleteSuggestions(userText: String, completion: @escaping ([String]) -> Void) {
        var possibleMatches: [String] = []
        interactor?.searchVar(phrase: userText) { vars in
            for item in vars { //2
                let myString: NSString! = item.lowercased() as NSString
                let substringRange: NSRange! = myString.range(of: userText.lowercased())

                if (substringRange.location == 0) {
                    possibleMatches.append(item)
                }
            }
            completion(possibleMatches)
        }
    }

    func putColourFormattedTextInTextField(autocompleteResult: String, userQuery : String) {
        let colouredString: NSMutableAttributedString = NSMutableAttributedString(string: userQuery + autocompleteResult)
        colouredString.addAttribute(.foregroundColor, value: UIColor.Label.gray, range: NSRange(location: userQuery.count,length:autocompleteResult.count))
        searchFld.attributedText = colouredString
    }
    func moveCaretToEndOfUserQueryPosition(userQuery : String) {
        if let newPosition = searchFld.position(from: searchFld.beginningOfDocument, offset: userQuery.count) {
            searchFld.selectedTextRange = searchFld.textRange(from: newPosition, to: newPosition)
        }
        let selectedRange: UITextRange? = searchFld.selectedTextRange
        searchFld.offset(from: searchFld.beginningOfDocument, to: (selectedRange?.start)!)
    }
    func formatAutocompleteResult(substring: String, possibleMatches: [String]) -> String {
        var autoCompleteResult = possibleMatches[0]
        autoCompleteResult.removeSubrange(autoCompleteResult.startIndex..<autoCompleteResult.index(autoCompleteResult.startIndex, offsetBy: substring.count))
        autoCompleteCharacterCount = autoCompleteResult.count
        return autoCompleteResult
    }
}

extension SearchMusicViewController: UICollectionViewDataSource {

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return items.count
    }
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withCell: SearchMusicCollectionViewCell.self, for: indexPath)
        cell.configure(item: items[indexPath.row])
        return cell
    }

}
extension SearchMusicViewController: UICollectionViewDelegate {

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        router?.navigateToAlbum(number: indexPath.row)
    }
    func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath){
        if indexPath.row == items.count-1 {
            interactor?.moreResult()
        }
    }
}
extension SearchMusicViewController: UICollectionViewDelegateFlowLayout {

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let width = self.view.bounds.width/2.5
        return CGSize(width: width, height: 65)
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 10
    }
}
