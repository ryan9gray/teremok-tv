//
//  SearchMusicInteractor.swift
//  Teremok-TV
//
//  Created by Evgeny Ivanov on 14/04/2019.
//  Copyright (c) 2019 xmedia. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SearchMusicBusinessLogic {
    var hasMore : Bool { get }
    func search(phrase: String)
    func searchVar(phrase: String, completion: @escaping ([String]) -> Void)
    func moreResult()
}

protocol SearchMusicDataStore {
    var albums: [MusicPlaylistItemResponse] { get }
    //var mainResponse: MusicSearchtResponse? { get }
}

class SearchMusicInteractor: SearchMusicBusinessLogic, SearchMusicDataStore {

    var presenter: SearchMusicPresentationLogic?    
    let service: SearchMusicProtocol = SearchMusicService()
    // MARK: Do something

    var nextShift: Int?
    let countSearch = 10
    var hasMore : Bool = true
    var mainResponse: MusicSearchtResponse?
    var albums: [MusicPlaylistItemResponse] = []
    var phrase: String?

    func searchVar(phrase: String, completion: @escaping ([String]) -> Void) {
        service.searchVar(phrase: phrase) { response in
            switch response {
            case .success(let response):
                if let vars = response.phrases {
                    completion(vars)
                }
            case .failure:
                completion([])
            }
        }
    }

    func search(phrase: String) {
        service.search(phrase: phrase, itemsOnPage: countSearch, shiftItem: 0) { [weak self] response in
            switch response {
            case .success(let response):
                self?.phrase = phrase
                self?.response(response, isNew: true)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
            }
        }
    }

    func moreResult() {
        guard let phrase = self.phrase, hasMore else { return }

        service.search(phrase: phrase, itemsOnPage: countSearch, shiftItem: nextShift ?? 0) { [weak self] response in
            switch response {
            case .success(let response):
                self?.response(response, isNew: false)
            case .failure(let error):
                self?.presenter?.presentError(error: error)
            }
        }
    }
    func response(_ response: MusicSearchtResponse, isNew: Bool){
        mainResponse = response
        nextShift = response.startItemIdInNextPage
        hasMore = response.items.count > 0
        if isNew {
            albums = response.items
        } else {
            albums.append(contentsOf: response.items)
        }
        presenter?.present(tracks: albums)
    }
}
